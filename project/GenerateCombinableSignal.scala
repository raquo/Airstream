import sbt._

import java.io.File

case class GenerateCombinableSignal(
    sourceDir: File,
    from: Int,
    to: Int
) extends SourceGenerator(
      sourceDir / "scala" / "com" / "raquo" / "airstream" / "combine" / "generated" / s"CombinableSignal.scala"
    ) {

  override def apply(): Unit = {
    line("package com.raquo.airstream.combine.generated")
    line()
    line("import app.tulz.tuplez.Composition")
    line("import com.raquo.airstream.combine.SampleCombineSignalN")
    line("import com.raquo.airstream.core.Signal")
    line("import com.raquo.airstream.core.Source.SignalSource")
    line("import com.raquo.ew.JsArray")
    line()
    line(
      "// #Warning do not edit this file directly, it is generated by GenerateCombinableSignal.scala"
    )
    line()
    line(
      "// These combine / combineWith / withCurrentValueOf / sample methods are implicitly available on all signals"
    )
    line(
      "// For combine / combineWith methods on the Signal companion object, see StaticSignalCombineOps.scala"
    )
    line()
    enter(
      "class CombinableSignal[A](val signal: Signal[A]) extends AnyVal {",
      "}"
    ) {
      line()
      for (n <- (from - 1) until to) {
        enter(s"def combineWith[${tupleType(n)}](") {
          line((1 to n).map(i => s"s${i}: SignalSource[T${i}]").mkString(", "))
        }
        enter(
          s")(implicit c: Composition[A, (${tupleType(n)})]): Signal[c.Composed] = {",
          "}"
        ) {
          line(
            s"combineWithFn(${tupleType(n, "s")})((a, ${tupleType(n, "v")}) => c.compose(a, (${tupleType(n, "v")})))"
          )
        }
        line()
        line("/** @param combinator Must not throw! */")
        enter(s"def combineWithFn[${tupleType(n)}, Out](") {
          line((1 to n).map(i => s"s${i}: SignalSource[T${i}]").mkString(", "))
        }
        enter(")(") {
          line(s"combinator: (A, ${tupleType(n)}) => Out")
        }
        enter(s"): Signal[Out] = {", "}") {
          line(
            s"StaticSignalCombineOps.combineWithFn(signal, ${tupleType(n, "s")})(combinator)"
          )
        }
        line()
        enter(s"def withCurrentValueOf[${tupleType(n)}](") {
          line((1 to n).map(i => s"s${i}: SignalSource[T${i}]").mkString(", "))
        }
        enter(
          s")(implicit c: Composition[A, (${tupleType(n)})]): Signal[c.Composed] = {",
          "}"
        ) {
          line(
            s"val combinator = (arr: JsArray[Any]) => c.compose(arr(0).asInstanceOf[A], (${(1 to n)
                .map(i => s"arr(${i}).asInstanceOf[T${i}]")
                .mkString(", ")}))"
          )
          line(
            s"val sampledSignals = JsArray[Signal[Any]](${tupleType(n, "s", ".toObservable")})"
          )
          enter(s"new SampleCombineSignalN(", ")") {
            line("signal, sampledSignals, combinator")
          }
        }
        line()
        enter(s"def sample[${tupleType(n)}](") {
          line((1 to n).map(i => s"s${i}: SignalSource[T${i}]").mkString(", "))
        }
        enter(s"): Signal[(${tupleType(n)})] = {", "}") {
          line(s"val combinator = (arr: JsArray[Any]) => (${(1 to n)
              .map(i => s"arr(${i}).asInstanceOf[T${i}]")
              .mkString(", ")})")
          line(
            s"val sampledSignals = JsArray[Signal[Any]](${tupleType(n, "s", ".toObservable")})"
          )
          enter(s"new SampleCombineSignalN[Any, (${tupleType(n)})](", ")") {
            line("signal, sampledSignals, combinator")
          }
        }
        line()
        line("// --")
        line()
      }
    }
  }

}
