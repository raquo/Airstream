package com.raquo.airstream.combine.generated

import com.raquo.airstream.UnitSpec
import com.raquo.airstream.core.{EventStream, Observer}
import com.raquo.airstream.eventbus.EventBus
import com.raquo.airstream.fixtures.TestableOwner

import scala.collection.mutable

// #Warning do not edit this file directly, it is generated by GenerateCombineStreamsTest.scala

class CombineStreamsSpec extends UnitSpec {

  case class T1(v: Int)
  case class T2(v: Int)
  case class T3(v: Int)
  case class T4(v: Int)
  case class T5(v: Int)
  case class T6(v: Int)
  case class T7(v: Int)
  case class T8(v: Int)
  case class T9(v: Int)

  it("CombineStream2 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()

    val combinedStream = EventStream.combine(bus1, bus2)

    val effects = mutable.Buffer[(T1, T2)]()

    val observer = Observer[(T1, T2)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.toList shouldBe List(
      (T1(0), T2(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      effects.toList shouldBe List(
        (T1(iteration), T2(iteration - 1)),
        (T1(iteration), T2(iteration))
      )
    }

    subscription.kill()
  }

  it("CombineStream3 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()

    val combinedStream = EventStream.combine(bus1, bus2, bus3)

    val effects = mutable.Buffer[(T1, T2, T3)]()

    val observer = Observer[(T1, T2, T3)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      effects.toList shouldBe List(
        (T1(iteration), T2(iteration - 1), T3(iteration - 1)),
        (T1(iteration), T2(iteration), T3(iteration - 1)),
        (T1(iteration), T2(iteration), T3(iteration))
      )
    }

    subscription.kill()
  }

  it("CombineStream4 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()
    val bus4 = new EventBus[T4]()

    val combinedStream = EventStream.combine(bus1, bus2, bus3, bus4)

    val effects = mutable.Buffer[(T1, T2, T3, T4)]()

    val observer = Observer[(T1, T2, T3, T4)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.shouldBeEmpty

    bus4.writer.onNext(T4(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0), T4(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      bus4.emit(T4(iteration))
      effects.toList shouldBe List(
        (
          T1(iteration),
          T2(iteration - 1),
          T3(iteration - 1),
          T4(iteration - 1)
        ),
        (T1(iteration), T2(iteration), T3(iteration - 1), T4(iteration - 1)),
        (T1(iteration), T2(iteration), T3(iteration), T4(iteration - 1)),
        (T1(iteration), T2(iteration), T3(iteration), T4(iteration))
      )
    }

    subscription.kill()
  }

  it("CombineStream5 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()
    val bus4 = new EventBus[T4]()
    val bus5 = new EventBus[T5]()

    val combinedStream = EventStream.combine(bus1, bus2, bus3, bus4, bus5)

    val effects = mutable.Buffer[(T1, T2, T3, T4, T5)]()

    val observer = Observer[(T1, T2, T3, T4, T5)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.shouldBeEmpty

    bus4.writer.onNext(T4(0))
    effects.shouldBeEmpty

    bus5.writer.onNext(T5(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0), T4(0), T5(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      bus4.emit(T4(iteration))
      bus5.emit(T5(iteration))
      effects.toList shouldBe List(
        (
          T1(iteration),
          T2(iteration - 1),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration - 1),
          T5(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration)
        )
      )
    }

    subscription.kill()
  }

  it("CombineStream6 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()
    val bus4 = new EventBus[T4]()
    val bus5 = new EventBus[T5]()
    val bus6 = new EventBus[T6]()

    val combinedStream = EventStream.combine(bus1, bus2, bus3, bus4, bus5, bus6)

    val effects = mutable.Buffer[(T1, T2, T3, T4, T5, T6)]()

    val observer = Observer[(T1, T2, T3, T4, T5, T6)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.shouldBeEmpty

    bus4.writer.onNext(T4(0))
    effects.shouldBeEmpty

    bus5.writer.onNext(T5(0))
    effects.shouldBeEmpty

    bus6.writer.onNext(T6(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0), T4(0), T5(0), T6(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      bus4.emit(T4(iteration))
      bus5.emit(T5(iteration))
      bus6.emit(T6(iteration))
      effects.toList shouldBe List(
        (
          T1(iteration),
          T2(iteration - 1),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration - 1),
          T6(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration)
        )
      )
    }

    subscription.kill()
  }

  it("CombineStream7 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()
    val bus4 = new EventBus[T4]()
    val bus5 = new EventBus[T5]()
    val bus6 = new EventBus[T6]()
    val bus7 = new EventBus[T7]()

    val combinedStream =
      EventStream.combine(bus1, bus2, bus3, bus4, bus5, bus6, bus7)

    val effects = mutable.Buffer[(T1, T2, T3, T4, T5, T6, T7)]()

    val observer = Observer[(T1, T2, T3, T4, T5, T6, T7)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.shouldBeEmpty

    bus4.writer.onNext(T4(0))
    effects.shouldBeEmpty

    bus5.writer.onNext(T5(0))
    effects.shouldBeEmpty

    bus6.writer.onNext(T6(0))
    effects.shouldBeEmpty

    bus7.writer.onNext(T7(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0), T4(0), T5(0), T6(0), T7(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      bus4.emit(T4(iteration))
      bus5.emit(T5(iteration))
      bus6.emit(T6(iteration))
      bus7.emit(T7(iteration))
      effects.toList shouldBe List(
        (
          T1(iteration),
          T2(iteration - 1),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration - 1),
          T7(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration)
        )
      )
    }

    subscription.kill()
  }

  it("CombineStream8 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()
    val bus4 = new EventBus[T4]()
    val bus5 = new EventBus[T5]()
    val bus6 = new EventBus[T6]()
    val bus7 = new EventBus[T7]()
    val bus8 = new EventBus[T8]()

    val combinedStream =
      EventStream.combine(bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8)

    val effects = mutable.Buffer[(T1, T2, T3, T4, T5, T6, T7, T8)]()

    val observer = Observer[(T1, T2, T3, T4, T5, T6, T7, T8)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.shouldBeEmpty

    bus4.writer.onNext(T4(0))
    effects.shouldBeEmpty

    bus5.writer.onNext(T5(0))
    effects.shouldBeEmpty

    bus6.writer.onNext(T6(0))
    effects.shouldBeEmpty

    bus7.writer.onNext(T7(0))
    effects.shouldBeEmpty

    bus8.writer.onNext(T8(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0), T4(0), T5(0), T6(0), T7(0), T8(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      bus4.emit(T4(iteration))
      bus5.emit(T5(iteration))
      bus6.emit(T6(iteration))
      bus7.emit(T7(iteration))
      bus8.emit(T8(iteration))
      effects.toList shouldBe List(
        (
          T1(iteration),
          T2(iteration - 1),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration - 1),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration),
          T8(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration),
          T8(iteration)
        )
      )
    }

    subscription.kill()
  }

  it("CombineStream9 works") {

    implicit val testOwner: TestableOwner = new TestableOwner

    val bus1 = new EventBus[T1]()
    val bus2 = new EventBus[T2]()
    val bus3 = new EventBus[T3]()
    val bus4 = new EventBus[T4]()
    val bus5 = new EventBus[T5]()
    val bus6 = new EventBus[T6]()
    val bus7 = new EventBus[T7]()
    val bus8 = new EventBus[T8]()
    val bus9 = new EventBus[T9]()

    val combinedStream =
      EventStream.combine(bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8, bus9)

    val effects = mutable.Buffer[(T1, T2, T3, T4, T5, T6, T7, T8, T9)]()

    val observer = Observer[(T1, T2, T3, T4, T5, T6, T7, T8, T9)](effects += _)

    // --

    effects.shouldBeEmpty

    // --
    val subscription = combinedStream.addObserver(observer)
    effects.shouldBeEmpty

    // --

    bus1.writer.onNext(T1(0))
    effects.shouldBeEmpty

    bus2.writer.onNext(T2(0))
    effects.shouldBeEmpty

    bus3.writer.onNext(T3(0))
    effects.shouldBeEmpty

    bus4.writer.onNext(T4(0))
    effects.shouldBeEmpty

    bus5.writer.onNext(T5(0))
    effects.shouldBeEmpty

    bus6.writer.onNext(T6(0))
    effects.shouldBeEmpty

    bus7.writer.onNext(T7(0))
    effects.shouldBeEmpty

    bus8.writer.onNext(T8(0))
    effects.shouldBeEmpty

    bus9.writer.onNext(T9(0))
    effects.toList shouldBe List(
      (T1(0), T2(0), T3(0), T4(0), T5(0), T6(0), T7(0), T8(0), T9(0))
    )

    // --
    for (iteration <- 1 to 10) {
      effects.clear()
      bus1.emit(T1(iteration))
      bus2.emit(T2(iteration))
      bus3.emit(T3(iteration))
      bus4.emit(T4(iteration))
      bus5.emit(T5(iteration))
      bus6.emit(T6(iteration))
      bus7.emit(T7(iteration))
      bus8.emit(T8(iteration))
      bus9.emit(T9(iteration))
      effects.toList shouldBe List(
        (
          T1(iteration),
          T2(iteration - 1),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration - 1),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration - 1),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration - 1),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration - 1),
          T7(iteration - 1),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration - 1),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration),
          T8(iteration - 1),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration),
          T8(iteration),
          T9(iteration - 1)
        ),
        (
          T1(iteration),
          T2(iteration),
          T3(iteration),
          T4(iteration),
          T5(iteration),
          T6(iteration),
          T7(iteration),
          T8(iteration),
          T9(iteration)
        )
      )
    }

    subscription.kill()
  }

}
